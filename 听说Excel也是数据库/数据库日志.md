# 数据库日志
>2017-02-17 20:30 

## Oracle
* 日期比较
	 ```sql
	select (case when a>to_date('2016-10-28','yyyy-mm-dd') then a else to_date('2016-10-28','yyyy-mm-dd') end)  from test
	```
* 批量存储
	```sql
	DECLARE
	  i number := 0;
	BEGIN
	  for i in 1 .. 1000 loop
	    insert into A_PROJECT_TOOL_GT_FORCAST (project_id, project_name, type,status) values (i,'test',1,1);
	  end loop;
	  commit;
	END;
	```
* 外链接
	`SELECT a.*, b.* from a(+) = b` 右连接 , 等同于`select a.*, b.* from a right join b`
	`SELECT a.*, b.* from a = b(+)` 左连接 , 等同于`select a.*, b.* from a left join b`
## MySql
* 相同列拼接
	```sql
	SELECT GROUP_CONCAT(id) id  FROM category
	--默认情况下是以 , 进行分割 , 另外默认长度为1024, 超出长度需要设置
	SET GLOBAL group_concat_max_len=102400;
	```
* 常用函数

  ```sql
  SELECT CHAR_LENGTH('你好123') -- 5
  SELECT LENGTH('你好123') -- 9
  SELECT CONCAT('12','34') -- 1234
  SELECT CONCAT_WS('@','12','34') -- 12@34 同CONCAT(s1,s2,...) 函数 , 但是每个字符串直接要加上x
  SELECT LEFT('abcde',2) -- ab 返回字符串s的前n个字符
  SELECT RIGHT('abcde',2) -- de
  SELECT TRIM('@' FROM '@@abc@@') -- abc 去掉字符串s中开始处和结尾处的字符串s1
  SELECT STRCMP('A',''B) ---字符串比较
  SELECT SUBSTRING(s,n,len) ---获取从字符串s中的第n个位置开始长度为len的字符串
  SELECT LOCATE('b', 'abc') -- 2 从字符串s中获取s1的开始位置
  SELECT FIELD('c','a','b','c') -- 3 FIELD(s,s1,s2...) 返回第一个与s匹配的字符串位置
  SELECT FIND_IN_SET(s1,s2) --s1是单个字符 ,s2为 , 分割的字符串 . 结果是s1在s2里面的位置
  SELECT CURRENT_DATE()-- 当前时间
  SELECT SHORT_UUID()--用途还未十分清晰
  ```

* MySql优化

  - 避免隐式转换

  - 查询字段尽量避免null

  - 合理使用联合索引以及覆盖索引

  - 避免使用in查询 (会导致临时表 , 增加io和网络)

  - 利用schema_redundant_indexes 查看多余索引

  - Profile:查询到 SQL 会执行多少时间 , 并看出 CPU/Memory 使用量 , 执行过程中 Systemlock, Table lock 花多少时间等等

  - 确定只有一条数据时 , 可以使用limit1

  - [explain](https://zhuanlan.zhihu.com/p/51771446)

    - id: SELECT 查询的标识符 . 每个 SELECT 都会自动分配一个唯一的标识符 .

    - select_type: SELECT 查询的类型 .

    - table: 查询的是哪个表

    - type: join 类型``ALL < index < range ~ index_merge < ref < eq_ref < const < system``

    - possible_keys: 此次查询中可能选用的索引

    - key: 此次查询中确切使用到的索引 .

    - ref: 哪个字段或常数与 key 一起被使用

    - rows: 显示此查询一共扫描了多少行 . 这个是一个估计值 .

    - filtered: 表示此查询条件所过滤的数据的百分比

    - extra:

      Using index : 使用覆盖索引 , 表示查询索引就可查到所需数据 不需要徽标
      Using Where : 在存储引擎检索行后再进行过滤 , 使用了where从句来限制哪些行将与下一张表匹配或者是返回给用户 .
      Using temporary : 使用了临时表
      Using filesort : 使用了外部索引排序

  - 可以考虑使用mysql的分区

## SQL执行顺序
* 在查询过程中聚合语句 (sum,min,max,avg,count) 要比having子句优先执行 . 而where子句在查询过程中执行优先级别优先于聚合语句 .having就是来弥补where在分组数据判断时的不足 . 因为where执行优先级别要快于聚合语句 .

