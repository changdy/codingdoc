# 面试准备
> Writen By CoolGhost,Started With 2016/10

* 连接Oracle数据库操作
	```java
	ResultSet rs = null;
	Statement stmt = null;
	Connection conn = null;
	try {
	    Class.forName("oracle.jdbc.driver.OracleDriver");
	    conn = DriverManager.getConnection("jdbc:oracle:thin:@ip:port", "username", "password");
	    stmt = conn.createStatement();
	    rs = stmt.executeQuery("select * from dept");
	    while (rs.next()) {
	        System.out.println(rs.getString("deptno"));
	    }
	} catch (ClassNotFoundException e) {
	    e.printStackTrace();
	} catch (SQLException e) {
	    e.printStackTrace();
	} finally {
	    try {
	        if (rs != null) {
	            rs.close();
	            rs = null;
	        }
	        if (stmt != null) {
	            stmt.close();
	            stmt = null;
	        }
	        if (conn != null) {
	            conn.close();
	            conn = null;
	        }
	    } catch (SQLException e) {
	        e.printStackTrace();
	    }
	}
	```
* java单例模式
	```java
	public class Singleton {
	  private Singleton() {}
	  private static Singleton single=null;
	  public static Singleton getInstance() {
	       if (single == null) {
	           single = new Singleton();
	       }
	      return single;
	  }
	}
	```
* java多线程
继承Thread类、实现Runnable接口、还有另外一种不常用。
* java路径
	两种方法：一种是`\\`另外一种是`/`
* java正则
	```java
	public class RegexMatches
	{
	    private static final String REGEX = "\\bcat\\b";
	    private static final String INPUT =
	            "cat cat cat cattie cat";
	    public static void main( String args[] ){
	        Pattern p = Pattern.compile(REGEX);
	        Matcher m = p.matcher(INPUT); // 获取 matcher 对象
	        int count = 0;
	        while(m.find()) {
	            count++;
	            System.out.println("Match number "+count);
	            System.out.println("start(): "+m.start());
	            System.out.println("end(): "+m.end());
	        }
	    }
	}
	```
	注意，java中只用正则`\`需要进行转义，如`\\d`
* String、StringBuffer、StringBuilder
	* 其中，String被final修饰，为不可变类，不能被继承，并且其值不能被改变。进行添加操作的时候会转换成 StringBuffer类型
	* StringBuffer、StringBuilder均为可变类，其功能基本类似，但是StringBuilder线程不安全
	* String因为是不可变类，因此不适合用来频繁的进行修改操作，而StirngBuilder和StringBuffer主要看是否运用在多线程中。另外三者都是借助`char[]`实现
* 浮点默认为dobule类型，如需float类型，（float）0.1或0.1f
* Switch
基本类型中long、float、double类型不能用于switch、而非基本类型的String可以用于switch
* 线程
	线程也被称为轻量级进程，是程序执行的最小单元，一个进程可以拥有多个线程，各个线程之间共享程序的内存空间。
* 多线程有点
	* 多线程可以减少程序响应时间
	* 线程的创建和切换开销较小
	* 单线程浪费多CPU执行能力
	* 多线程能简化程序结构，便于理解和维护
* Servlet的生命周期
	初始化阶段：调用init()方法；响应客户请求阶段：调用service()方法，并依据请求类型调用dopost和doget方法；终止阶段：调用destroy()方法。另外Servlet是单利多线程
* java读取文件
	```java
	//字节流,不会出现乱码
    File file=new File(filePath);
    if(file.isFile() && file.exists()){ //判断文件是否存在
        InputStreamReader read = new InputStreamReader(new FileInputStream(file),encoding);//考虑到编码格式
        BufferedReader bufferedReader = new BufferedReader(read);
        String lineTxt = null;
        while((lineTxt = bufferedReader.readLine()) != null){
            System.out.println(lineTxt);
        }
        read.close();
    }else{
        System.out.println("找不到指定的文件");
    }
	```
	```java
	//字符流，可能出现乱码
	FileReader fr=new FileReader(filePath);
    BufferedReader bufferedReader = new BufferedReader(fr);
	```
* servlet和cgi
	servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。
* jsp跳转方式
	有两种：
	* forward跳转：<jsp:forward page ="跳转页面地址">
		* 服务器端跳转，地址栏不改变。
		* 执行到跳转语句后马上执行跳转，之后的代码不再执行（跳转之前一定要释放全部资源）。
		* request设置的属性在跳转后的页面仍然可以使用。
	* response跳转：response.sendRedirect("跳转页面地址")
		* 客户端跳转，地址栏改变。
		* 所有代码执行完毕后跳转。
		* 跳转后页面不能使用上一个页面的request。
		* 使用地址重写传递参数（response.sendRedirect("URL?参数名=参数值")）。
* java数组初始化赋值
	```java
	int[] nums = {0,1,2,3,4,5,6,7,8,9};
	int[] nums = new int[]{0,1,2,3,4,5,6,7,8,9};
	```
* 抽象类
其子类权限只能扩大，不能缩小。
* java static
	```java
	public class Alpha {
	    static int i = 1;
	    static {
	        i++;
	    }
	    public Alpha() {
	        i++;
	    }
	    public static void main(String[] args) {
	        Alpha t1 = new Alpha();
	        System.out.println(t1.i);       //3
	        Alpha t2 = new Alpha();
	        System.out.println(t2.i);//4 静态资源只执行一次
	    }
	}
	```
* java运算符
	* && 大于 ||
	* 大于等于，小于等于分别只有一种表达方式>=、<=
* SQL操作
	```sql
	--修改表名
	alter table table_name rename to new_name
	--修改列名
	alter table table_name rename colnumn_name to new_name
	--更改列属性
	alter table table_name modify colnumn_name varchar(20)
	--删除列
	alter table table_name drop colnumn_name
	--增加列
	alter table table_name add colnumn_name varchar(20)
	--case语句
	select （case when a>b then a else b end） from table_name
	```
* SQL 范式
	* 必须有主键，列不可分
	* 确保表中的每列都和主键相关
	* 每列都和主键列直接相关,而不是间接相关
* SQL truncate 、delete与drop区别
	* truncate 和 delete 只删除数据不删除表的结构
	* delete 语句是数据库操作语言(dml),事务提交之后才生效。truncate、drop 是数据库定义语言(ddl)，立即生效，不处罚事务。
* 默认是升序asc，desc为降序
* Oracle转换成日期格式的方法为`to_date`,如to_date('02-01-1999','MM-DD-YYYY')，日期转换成字符串用to_char方法如to_char(sys_date,'hh:mi:ss')
* mybatis
	* `statementType`设置为`CALLABLE`，默认情况下是`PREPARED`
	* 一般使用#，$符号只有在特定情况下，如表前缀才使用，可能带来SQL注入
	* jdbctype如果不设定，并且如果参数为null，则会1111错误
* spring mvc
	* 运行流程
		![流程](https://public.lightpic.info/image/8E84_5864786A0.jpg)
		* 用户发送请求时，首先被DispatcherServlet捕获
		* DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping
		* HandlerMapping根据请求，访问不同Controller进行处理
		* Controller进行业务的处理，完成后将返回的数据和跳转到的界面封装到ModelAndView
		* ViewResolver解析Controller返回的ModelAndView，读取其信息，然后渲染界面完成一次请求
	* `mvc:view-controller`,让请求不通过Handler，直接访问到响应视图。而在配置这个标签之后，默认的@RequestMapping将会失效，这个时候需要配置`mvc:annotation-driven`。而`mvc:resources`则是用来配置静态资源比如：css，js之类。
* spring 
	* ioc降低了项目资源的耦合程度，不适用new来生成。
	* aop则是对oop的补充，让核心代码只关注相应功能。
* jdk jre
	* Java Runtime Enviroment 运行时库，可以让java程序运行。
	* Java Development Kit 开发库，支持java开发，包括编译器（javac.exe）、开发工具（javadoc.exe、jar.exe、keytool.exe、jconsole.exe）和更多的类库（如tools.jar）等。
* jQuery选择器
id选择器、类选择器、元素选择器
* jsp内置对象
request、response、session、out、page、application、exception、pageContext、config
* http协议
	* Accept：用于高速服务器，客户机支持的数据类型
	* Accept-Charset：用于告诉服务器，客户机采用的编码格式
	* Accept-Encoding：用于告诉服务器，客户机支持的数据压缩格式
	* Accept-Language：客户机的语言环境
	* Host：客户机通过这个头高速服务器，想访问的主机名
	* User-Agent：客户机通过这个头告诉服务器，客户机的软件环境
	* Cookie：客户机通过这个头可以向服务器带数据
	* Connection：处理完这次请求后是否断开连接还是继续保持连接
	* Date：当前时间值
* 重写与重载
	* override是重写（覆盖）了一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写（重新实现）父类中的方法。
		* 重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载.
		* 重写方法的访问修饰符一定要大于被重写方法的访问修饰符（public>protected>default>private）。
		* 重写的方法的返回值必须和被重写的方法的返回一致；
		* 重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类；
		* 被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。
		* 静态方法不能被重写为非静态的方法（会编译出错）。
	* overload是重载，一般是用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同。
		* 在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序（参数类型必须不一样）；
		* 不能通过访问权限、返回类型、抛出的异常进行重载；
		* 方法的异常类型和数目不会对重载造成影响；
* 抽象方法
	抽象方法是一种特殊的方法；它只有声明，而没有具体的实现。抽象方法的声明格式为：
	```java
	abstract void test();
	```
* 抽象类和接口的区别
	* 抽象类可以提供成员方法的实现细节，而接口中只能是public abstract 方法；
	* 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
	* 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
	* 一个类只能继承一个抽象类，而一个类却可以实现多个接口。
	* 都不能实例化
* 结合框架
	* collection下面有set和list，map下面有hashmap和hashtable，list有序，可以重复，set不能重复。
	* ArrayList是线程不安全的，Vector 是线程安全的，这两个类底层都是由数组实现的，LinkedList是线程不安全的，底层是由链表实现的。
	* HashTable 是线程安全的，不能存储 null 值，HashMap线程不安全，可以存储null值，并且hashmap无contains方法
* java异常
java有俩种异常类型：受检查异常和不受检查检查异常
	* 检查异常，这些异常从程序的角度来说是必须经过捕捉处理的，否则编译通不过，比如IOException，SQLException。
	* 不受检查异常：分为Error和RuntimeException
	Error是程序无法处理的如OutOfMemoryError，如果出现Error，java虚拟机会终止线程。
	RunTimeException运行时异常，如IndexOutOfBoundsException，NullPointerException，这些异常一般是由程序的逻辑错误引起的，解决此类异常应该仔细排查程序，不需要进行检查。
* Java中Exception和Error有什么区别？
Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。
* jdbc
JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用 Java语言 编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序
* http报文结构
	* HTTP的请求报文的组成：
	请求方法 + 请求的资源的URI + 协议版本 + 可选的请求首部字段 + 内容实体。
	* HTTP的响应报文的组成：
	协议版本 + 状态码 + 用于解释状态码的原因短语 + 可选的响应首部字段 + 实体主体。